#!/usr/bin/php
<?php
/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
/*
 * We need to prevent that ComponentsNeeded tries to load classes which were
 * already declared by PHP. However, we also need to prevent that
 * ComponentsNeeded doesn't load classes which were declared within the script
 * itself! Therefore, we get all of PHP's classes & interfaces at the very
 * beginning of the script and use it for further reference on which classes
 * should be ignored or not.
 * Also, we use parseFile to search which classes are defined within ourselves,
 * otherwise we couldn't use a version of phuild.php generated by phuild with
 * sources included. 
 */
$declared = array_merge(get_declared_classes(), get_declared_interfaces());
function parseFile($file):array {
	$string = file_get_contents($file);
	$tokens = token_get_all($string);
	$names = array();
	$interesting = array(T_CLASS, T_INTERFACE);
	foreach($tokens as $key => $value) {
		if(!is_array($value)) {
			continue;
		}
		if(!in_array($value[0], $interesting)) {
			continue;
		}
		if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
			continue;
		}
		if($tokens[$key+1][0]!=T_WHITESPACE) {
			continue;
		}
		$names[] = $tokens[$key+2][1];
	}
return $names;
}
$decSelf = parseFile(__FILE__);
$ignore = array();
foreach($declared as $value) {
	if(in_array($value, $decSelf)) {
		continue;
	}
	$ignore[] = $value;
}
$ignore[] = "self";
$ignore[] = "parent";

#Include
#Imported from ./include/lib/Argv/ArgvModel.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Interface for model as expected by Argv.
 */
interface ArgvModel {
	public function getArgNames(): array;
	
	public function getNamedArg(string $name): ArgModel;

	public function getPositionalCount(): int;
	
	public function getPositionalArg(int $i): ArgModel;
	
	public function getPositionalName(int $i): string;
	
	/**
	 * return an array of pure boolean parameters without a value, which will
	 * evaluate to true if set.
	 */
	function getBoolean(): array;
}
#Imported from ./include/lib/Argv/ArgModel.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Interface for return value of Argv::getArgModel.
 *
 * ArgvModel allows to define parameters along with conversion and validation.
 * Examples may be to validate that a parameter like --date= contains a valid
 * date.
 */
interface ArgModel {
	/**
	 * returns a default value if it has one. If, for instance, --date is used,
	 * it could be set to „now“.
	 */
	function getDefault(): string;
	/**
	 * Should return whether an instance of ArgModel has a default value or not.
	 */
	function hasDefault():bool;
	/**
	 * Should return whether an instance of ArgModel has an instance of Validate
	 * defined.
	 */
	function hasValidate():bool;
	/**
	 * Should return an instance of Validate if there is one; Argv will then
	 * call it on the value given by a parameter. getValidate won't be called if
	 * hasValidate returns false.
	 */
	function getValidate():Validate;
	/**
	 * Should return whether an instance of ArgModel has an instance of Convert
	 * defined.
	 */
	function hasConvert():bool;
	/**
	 * Should return an instance of Convert if there is one; Argv will then use
	 * it to convert any input.
	 */
	function getConvert():Convert;
	function isMandatory():bool;
}
#Imported from ./include/lib/Argv/ArgString.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */
class ArgString implements ArgModel {
	private $default;
	private $mandatory = false;
	private $validate;
	private $convert;
	public function __construct() {
	}

	public function setMandatory(bool $mandatory) {
		$this->mandatory = $mandatory;
	}
	
	public function setConvert(Convert $convert) {
		$this->convert = $convert;
	}

	public function hasConvert(): bool {
		return $this->convert!==NULL;
	}
	
	public function getConvert(): Convert {
		return $this->convert;
	}

	public function setDefault(string $default) {
		$this->default = $default;
	}

	public function hasDefault(): bool {
		return $this->default!==NULL;
	}
	
	public function getDefault(): string {
		return $this->default;
	}

	public function setValidate(Validate $validate) {
		$this->validate = $validate;
	}

	public function hasValidate(): bool {
		return $this->validate!=NULL;
	}

	public function getValidate(): Validate {
		return $this->validate;
	}

	public function isMandatory(): bool {
		return $this->mandatory;
	}

}
#Imported from ./include/local/ArgvMain.php


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of ArgvMain
 *
 * @author hm
 */
class ArgvMain implements ArgvModel{
	private $arg = array();
	private $positional = array();
	private $positionalNames = array();
	public function __construct() {
		$this->arg["output"] = new ArgString();
		$this->positional[] = new ArgString();
		$this->positionalNames[] = "source";
	}
	public function getBoolean(): array {
		return array("source", "require", "check", "force");
	}

	public function getArgNames(): array {
		return array_keys($this->arg);
	}

	public function getNamedArg(string $name): \ArgModel {
		return $this->arg[$name];
	}

	public function getPositionalArg(int $i): \ArgModel {
		return $this->positional[$i];
	}

	public function getPositionalCount(): int {
		return count($this->positional);
	}

	public function getPositionalName(int $i): string {
		return $this->positionalNames[$i];
	}

}
#Imported from ./include/lib/LongestString.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Designed to get the length of the longest string of a set of strings.
 */
class LongestString {
	private $longest = 0;
	private $charset;
	/**
	 * 
	 * @param string $charset Character Set as expected by mb_strlen.
	 */
	function __construct(string $charset = "UTF-8") {
		$this->charset = $charset;
	}
	
	/**
	 * 
	 * @param string $string
	 */
	function addString(string $string) {
		$len = mb_strlen($string, $this->charset);
		if($len>$this->longest) {
			$this->longest = $len;
		}
	}
	
	/**
	 * 
	 * @param array $array
	 */
	function addArray(array $array) {
		foreach($array as $key => $value) {
			$this->addString($value);
		}
	}
	
	/**
	 * 
	 * @return int
	 */
	function getLongest(): int {
		return $this->longest;
	}
	
	/**
	 * set stored length to zero
	 */
	function reset() {
		$this->longest = 0;
	}
}
#Imported from ./include/lib/Argv/ArgvReference.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * ArgvReference prints out a simple reference of defined arguments.
 */

class ArgvReference {
	private $argvModel;
	function __construct(ArgvModel $model) {
		$this->argvModel = $model;
	}
	
	function getReference() {
		echo $this->getPositionalReference();
		echo $this->getNamedReference();
		echo $this->getBooleanReference();
	}
	
	private function getPositionalReference(): string {
		$count = $this->argvModel->getPositionalCount();
		if($count==0) {
			return "";
		}
		$return = "";
		$return .= "Positional Arguments:".PHP_EOL;
		for($i=0;$i<$count;$i++) {
			$return .= "\tArgument ".($i+1).": ";
			$return .= $this->argvModel->getPositionalName($i);
			$return .= PHP_EOL;
		}
	return $return;
	}
	
	private function getBooleanReference() {
		if(empty($this->argvModel->getBoolean())) {
			return "";
		}
		$return = "";
		$return .= "Boolean Arguments:".PHP_EOL;
		$longest = new LongestString();
		$longest->addArray($this->argvModel->getBoolean());
		foreach($this->argvModel->getBoolean() as $value) {
			$return .= "\t--".$value.PHP_EOL;
		}
	return $return;
	}
	
	private function getNamedReference(): string {
		$names = $this->argvModel->getArgNames();
		if(count($names)==0) {
			return "";
		}
		$longest = new LongestString();
		$longest->addArray($names);
		$return = "";
		$return .= "Named Arguments:".PHP_EOL;
		foreach($names as $name) {
			$arg = $this->argvModel->getNamedArg($name);
			$return .= "\t--".str_pad($name, $longest->getLongest(), " ");
			if($arg->isMandatory()) {
				$return .= " (mandatory)".PHP_EOL;
			} else {
				$return .= " (optional)".PHP_EOL;
			}
		}
	return $return;
	}
}
#Imported from ./include/lib/Argv/ArgvException.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */
class ArgvException extends RuntimeException {
}
#Imported from ./include/lib/Argv/Argv.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Argv extracts parameters from $argv, as defined in an ArgvModel. As of yet,
 * it only handles long parameters, such as --param, both with or without a
 * value.<br />
 * Argv does basic plausibility checks; it throws Exceptions if boolean
 * parameters are used with a value and vice versa or if unknown parameters are
 * used.
 */
class Argv {
	private $model;
	private $argv;
	private $availablePositional = array();
	private $availableNamed = array();
	private $availableBoolean = array();
	function __construct(array $argv, ArgvModel $model) {
		$this->model = $model;
		$this->argv = array_slice($argv, 1);
		$this->getAvailable();
		$this->sanityCheck();
		$this->validate();
	}
	
	private function getAvailable() {
		foreach($this->argv as $key => $value) {
			if(substr($value, 0, 2)=="--") {
				$this->getAvailableNamedOrBoolean($value);
				continue;
			}
			$this->availablePositional[] = $value;
		}
		$this->getDefaults();
	}
	
	private function getDefaults() {
		foreach ($this->model->getArgNames() as $name) {
			if(isset($this->availableNamed[$name])) {
				continue;
			}
			if(!$this->model->getNamedArg($name)->hasDefault()) {
				continue;
			}
			$this->availableNamed[$name] = $this->model->getNamedArg($name)->getDefault();
		}
	}
	
	private function getAvailableNamedOrBoolean(string $value) {
		$exp = explode("=", $value, 2);
		if(count($exp)==1) {
			$this->availableBoolean[] = substr($value, 2);
			return;
		}
		$this->availableNamed[substr($exp[0], 2)] = $exp[1];
	}
	
	private function sanityCheck() {
		$this->booleanSanity();
		$this->positionalSanity();
		$this->namedSanity();
	}
	
	private function booleanSanity() {
		$defined = $this->model->getBoolean();
		foreach($this->availableBoolean as $value) {
			if(!in_array($value, $defined)) {
				throw new ArgvException("unknown boolean parameter --".$value);
			}
		}
	}
	
	private function positionalSanity() {
		$defined = $this->model->getPositionalCount();
		for($i=0;$i<$defined;$i++) {
			if(!isset($this->availablePositional[$i])) {
				throw new ArgvException("Argument ".($i+1)." (".$this->model->getPositionalName($i).") missing");
			}
		}
		if(count($this->availablePositional)>$defined) {
			throw new ArgvException("Argument ".($defined+1)." not expected");
		}
	}
	
	private function namedSanity() {
		$defined = $this->model->getArgNames();
		foreach($defined as $name) {
			$arg = $this->model->getNamedArg($name);
			if(!isset($this->availableNamed[$name]) && $arg->isMandatory()) {
				throw new ArgvException("mandatory argument --".$name." missing");
			}
		}
		foreach (array_keys($this->availableNamed) as $value) {
			if(!in_array($value, $defined)) {
				throw new ArgvException("argument --".$value." not expected");
			}
		}
	}
	
	private function validate() {
		foreach($this->availablePositional as $pos => $value) {
			$arg = $this->model->getPositionalArg($pos);
			if(!$arg->hasValidate()) {
				continue;
			}
			try {
				$arg->getValidate()->validate($value);
			} catch (ValidateException $e) {
				throw new ArgvException("argument ".($pos+1)." (".$this->model->getPositionalName($pos)."): ".$e->getMessage());
			}
		}

		foreach($this->availableNamed as $name => $value) {
			$arg = $this->model->getNamedArg($name);
			if(!$arg->hasValidate()) {
				continue;
			}
			try {
				$arg->getValidate()->validate($value);
			} catch (ValidateException $e) {
				throw new ArgvException("--".$name.": ".$e->getMessage());
			}
			
		}

	}

	private function convert() {
		foreach($this->availablePositional as $pos => $value) {
			$arg = $this->model->getPositionalArg($pos);
			if(!$arg->hasConvert()) {
				continue;
			}
			$this->availablePositional[$pos] = $arg->getConvert()->convert($this->availablePositional[$pos]);
		}

		foreach($this->availableNamed as $name => $value) {
			$arg = $this->model->getNamedArg($name);
			if(!$arg->hasConvert()) {
				continue;
			}
			$this->availableNamed[$name] = $arg->getConvert()->convert($this->availableNamed[$name]);
		}
	}

	/**
	 * Checks whether a certain parameter is available or not. A parameter is
	 * available if it was used by the calling user or if it's ArgModel has a
	 * default value.
	 * @param type $key
	 * @return bool
	 */
	function hasValue($key):bool {
		return isset($this->availableNamed[$key]);
	}
	/**
	 * Gets the value of a specific parameter. Note that parameters which are
	 * not available will throw an exception, so hasValue should be called
	 * beforehand if a value is not mandatory and has no default value.
	 * 
	 * @param type $key
	 * @return string
	 * @throws Exception
	 */
	function getValue($key): string {
		if(!$this->hasValue($key)) {
			throw new Exception("argument value ".$key." doesn't exist");
		}
	return $this->availableNamed[$key];
	}
	
	function hasPositional(int $pos) {
		return isset($this->availablePositional[$pos]);
	}
	
	function getPositional(int $pos) {
		if(!$this->hasPositional($pos)) {
			throw new Exception("positional argument ".$pos." doesn't exist");
		}
	return $this->availablePositional[$pos];
	}
	
	/**
	 * getBoolean will evaluate to true if a parameter was set (like --force),
	 * and to false, if it was not set. It will throw an Exception if it was
	 * not defined in an instance of ArgvModel.
	 * @param type $key
	 * @return bool
	 * @throws Exception
	 */
	function getBoolean($key):bool {
		if(!in_array($key, $this->model->getBoolean())) {
			throw new Exception("boolean argument ".$key." is not defined");
		}
		return in_array($key, $this->availableBoolean);
	}
}
#Imported from ./include/local/ComponentsAvailable.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class ComponentsAvailable {
	private $classes;
	/**
	 * 
	 * @param string $directory
	 */
	function __construct(string $directory) {
		$this->addDirectory($directory);
	}
	
	/**
	 * Add Directory
	 * 
	 * Add another directory to an instance of ComponentsAvailable
	 * @param string $directory Directory containing PHP files
	 */
	function addDirectory(string $directory) {
		#Assert::fileExists($directory);
		#Assert::isDir($directory);
		if(!file_exists($directory)) {
			throw new InvalidArgumentException("directory ".$directory." does not exist.");
		}

		$this->recurse(realpath($directory));
	}

	/**
	 * Add File
	 * 
	 * Add a single file containing PHP classes.
	 * @param type $file
	 */
	function addFile($file) {
		#Assert::fileExists($file);
		#Assert::isFile($file);
		$this->parse($file);
	}
	
	private function recurse($folder) {
		foreach(glob($folder."/*") as $value) {
			$info = pathinfo($value);
			if(is_dir($value)) {
				$this->recurse($value);
				continue;
			}
			if(!isset($info["extension"])) {
				continue;
			}
			if($info["extension"]!="php") {
				continue;
			}
			$this->parse($value);
		}
	}
	
	/**
	 * Extract Components
	 * 
	 * Isolated method to extract components out of a PHP file. Isolated from
	 * parse() for better testing.
	 * @param type $file
	 * @return array
	 */
	static function extractComponents($file): array {
		$components = array();
		$string = file_get_contents($file);
		$tokens = token_get_all($string);
		
		$interesting = array(T_CLASS, T_INTERFACE);
		foreach($tokens as $key => $value) {
			if(!is_array($value)) {
				continue;
			}
			if(!in_array($value[0], $interesting)) {
				continue;
			}
			if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
				continue;
			}
			if($tokens[$key+1][0]!=T_WHITESPACE) {
				continue;
			}
			$components[] = $tokens[$key+2][1];
		}
	return $components;
	}
	
	private function parse($file) {
		$classes = self::extractComponents($file);
		foreach ($classes as $value) {
			$this->classes[$value] = $file;
		}
	}
	
	/**
	 * Has Component
	 * 
	 * Checks if an instance of ComponentsAvailable knows the whereabouts of a
	 * specific component.
	 * @param string $component
	 * @return bool
	 */
	public function hasComponent(string $component):bool {
		return isset($this->classes[$component]);
	}
	
	/**
	 * Get Component
	 * 
	 * Returns the path of the file that contains a certain Component. Throws an
	 * Exception if a Component cannot be resolved to a file.
	 * @param string $component
	 * @return type
	 * @throws Exception
	 */
	public function getComponent(string $component) {
		if(!$this->hasComponent($component)) {
			throw new Exception("component ".$component." not known.");
		}
		return $this->classes[$component];
	}
	
	/**
	 * Get Components
	 * 
	 * Get the components gathered by ComponentsAvailable.
	 * @return array
	 */
	function getComponents(): array {
		sort($this->classes);
	return $this->classes;
	}
}
#Imported from ./include/local/ComponentsNeeded.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class ComponentsNeeded {
	private $main;
	private $classes = array();
	private $components;
	private $ignore = array();
	const REQONCE = 1;
	const SOURCE = 2;
	/**
	 * Constructor
	 * 
	 * Needs a file to start upon and ComponentsAvailable to look up further
	 * files containing dependencies.
	 * $ignore contains component names which should be ignored altogether - for
	 * instance, PHP's builtin classes, which are determined by phuild.php right
	 * at the start of the script before anything else is done.
	 * 
	 * @param type $file
	 * @param ComponentsAvailable $ca
	 * @param array $ignore
	 */
	function __construct($file, ComponentsAvailable $ca, array $ignore) {
		#Assert::fileExists($file);
		if(!file_exists($file)) {
			throw new InvalidArgumentException("directory ".$file." does not exist.");
		}
		$this->main = realpath($file);
		$this->components = $ca;
		$this->ignore = $ignore;
		$this->parse($file);
	}

	/**
	 * AddClass
	 * 
	 * AddClass() adds a component to the stack of necessary components and
	 * parses deeper into the class hierarchy, IE if the first file showed that
	 * class Dog is needed, the file Dog will be parsed to determine further
	 * dependencies.
	 * 
	 * @param type $className
	 * @return type
	 */
	private function addClass($className) {
		if(in_array($className, $this->ignore)) {
			return;
		}
		if(!$this->components->hasComponent($className)) {
			$this->classes[] = $className;
			return;
		}

		/**
		 * Fill ignore first, to prevent that classes get added for several
		 * times.
		 */
		$this->ignore[] = $className;
		$this->parse($this->components->getComponent($className));
		/**
		 * Fill classes after parse, to ensure proper dependency, ie what's
		 * needed is added before what needs it.
		 */
		$this->classes[] = $className;
	}
	
	/**
	 * checkClassname
	 * 
	 * Checks if a classname is valid. By now, only variables instead of class
	 * names will result in a RuntimeException.
	 * @param type $classname
	 * @param type $filename
	 * @param int $line
	 * @throws RuntimeException
	 */
	private static function checkClassname($classname, $filename, int $line) {
		if($classname[0]=="\$") {
			throw new RuntimeException("class name ".$classname." in ".$filename." line ".$line." contains a variable.");
		}
	}
	
	/**
	 * extract needed
	 * 
	 * extractNeeded parses a file using PHP's own tokenizer. It then
	 * specifically looks for T_IMPLEMENTS, T_NEW, T_EXTENDS and T_DOUBLE_COLON,
	 * aka T_PAAMAYIM_NEKUDOTAYIM to determine which classes/interfaces are used
	 * within a file.
	 * Tokens between #Include and #/Include are skipped.
	 * 
	 * A runtime exception is thrown if a variable is used for a classname,
	 * ie new $name();. There is no way for phuild to determine the content.
	 * 
	 * @param string $file
	 * @return array
	 * @throws RuntimeException
	 */
	static function extractNeeded(string $file): array {
		$needed = array();
		$string = file_get_contents($file);
		$tokens = token_get_all($string);
		$interesting = array(T_IMPLEMENTS, T_EXTENDS, T_NEW);
		$ignore = FALSE;
		foreach($tokens as $key => $value) {
			if(!is_array($value)) {
				continue;
			}
			/*
			 * We have to ignore any #Include-Block, allowing the developer
			 * to for instance use a custom autoloader without it counting as
			 * a required component. 
			 */
			if($value[0] == T_COMMENT && trim($value[1]) == "#Include") {
				$ignore = true;
				continue;
			}
			if($value[0] == T_COMMENT && trim($value[1]) == "#/Include") {
				$ignore = FALSE;
				continue;
			}
			if($ignore==TRUE) {
				continue;
			}
			
			if($value[0]==T_DOUBLE_COLON) {
				$className = $tokens[$key-1][1];
				self::checkClassname($className, $file, $tokens[$key-1][2]);
				$needed[] = $className;
				continue;
			}
			if(!in_array($value[0], $interesting)) {
				continue;
			}
			if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
				continue;
			}
			if($tokens[$key+1][0]!=T_WHITESPACE) {
				continue;
			}
			$className = $tokens[$key+2][1];
			self::checkClassname($className, $file, $tokens[$key+2][2]);
			$needed[] = $className;
		}
	return $needed;
	}
	
	/**
	 * parse
	 * 
	 * parse() does little more than to call extractNeeded and then addClass on
	 * every result.
	 * @param type $file
	 */
	private function parse($file) {
		$components = self::extractNeeded($file);
		foreach($components as $className) {
			$this->addClass($className);
		}
	}
	
	function getClasses(): array {
		return $this->classes;
	}
	
	private function getRequireOnce(): string {
		$require = "";
		foreach($this->classes as $key => $value) {
			$require .= "require_once ".str_replace(dirname($this->main), "__DIR__.'", $this->components->getComponent($value))."';".PHP_EOL;
		}
	return $require;
	}
	
	private function getSource(): string {
		$replace = "";
		foreach($this->classes as $key => $value) {
			$file = trim(file_get_contents($this->components->getComponent($value)));
			$exp = explode(PHP_EOL, $file);
			$exp[0] = "#Imported from ".str_replace(dirname($this->main), ".", $this->components->getComponent($value)).PHP_EOL;
			if($exp[count($exp)-1]=="?>") {
				array_pop($exp);
			}
			$replace .= implode(PHP_EOL, $exp).PHP_EOL;
		}
	return $replace;
	}
	
	private function getReplace($type): string {
		$new = "";
		if($type==self::REQONCE) {
			$new .= $this->getRequireOnce();
		}
		if($type==self::SOURCE) {
			$new .= $this->getSource();
		}
	return $new;
	}
	
	function replace(int $type):string {
		$replace = false;
		$new = "";
		$handle = fopen($this->main, "r");
		while($line = fgets($handle)) {
			$trimmed = trim($line);
			if($trimmed=="#Include") {
				$new .= $line;
				$replace = true;
				continue;
			}
			if($trimmed=="#/Include") {
				$new .= $this->getReplace($type);
				$new .= $line;
				$replace = FALSE;
				continue;
			}
			if($replace==true) {
				continue;
			}
			$new .= $line;
		}
		fclose($handle);
	return $new;
	}
	
	private function printCheckResult(array $array, string $heading) {
		foreach($array as $key => $value) {
			if($key==0) {
				echo $heading.PHP_EOL;
			}
			echo "\t".$value.PHP_EOL;
		}
	}
	
	function check() {
		$available = array();
		$missing = array();
		foreach($this->classes as $value) {
			if($this->components->hasComponent($value)) {
				$available[] = $value;
			} else {
				$missing[] = $value;
			}
		}
		$this->printCheckResult($available, "Available Components:");
		$this->printCheckResult($missing, "Missing Components:");
	}
}
#Imported from ./include/local/Main.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class Main {
	private $file;
	private $target;
	private $sourcePath;
	private $needed;
	private $available;
	private $argv;
	function __construct(array $argv, array $ignore) {
		$model = new ArgvMain();
		if(!isset($argv[1])) {
			$reference = new ArgvReference($model);
			$reference->getReference();
			die();
		}
		$this->argv = new Argv($argv, $model);
		$boolean = array("source", "require", "check");
		$boolCount = 0;
		foreach($boolean as $value) {
			if($this->argv->getBoolean($value)) {
				$boolCount++;
			}
			if($boolCount>1) {
				throw new ArgvException("--source, --check and --require are mutually exclusive.");
			}
		}
		if($boolCount==0) {
			throw new ArgvException("Needs --source, --check or --require.");
		}
		$this->file = $this->argv->getPositional(0);
		$this->sourcePath = dirname($this->file);
		$this->available = new ComponentsAvailable($this->sourcePath);
		$this->needed = new ComponentsNeeded($this->file, $this->available, $ignore);
	}
	
	private function saveFile() {
		if($this->argv->getBoolean("check")) {
			return;
		}
		if($this->argv->getBoolean("source")) {
			$replaced = $this->needed->replace(ComponentsNeeded::SOURCE);
		}
		if($this->argv->getBoolean("require")) {
			$replaced = $this->needed->replace(ComponentsNeeded::REQONCE);
		}
		if(!$this->argv->hasValue("output")) {
			echo $replaced.PHP_EOL;
			return;
		}
		if(file_exists($this->argv->getValue("output")) && !$this->argv->getBoolean("force")) {
			throw new Exception("file ".$this->argv->getValue("output")." already exists, use --force to replace.");
		}
		file_put_contents($this->argv->getValue("output"), $replaced);
	}
	
	function run() {
		$this->saveFile();
		if($this->argv->getBoolean("check")) {
			$this->needed->check();
		}
	}
}
#/Include

try {
	$main = new Main($argv, $ignore);
	$main->run();
} catch (ArgvException $ex) {
	echo $ex->getMessage().PHP_EOL;
}