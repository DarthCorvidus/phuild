#!/usr/bin/php
<?php
/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
/*
 * We need to prevent that ComponentsNeeded tries to load classes which were
 * already declared by PHP. However, we also need to prevent that
 * ComponentsNeeded doesn't load classes which were declared within the script
 * itself! Therefore, we get all of PHP's classes & interfaces at the very
 * beginning of the script and use it for further reference on which classes
 * should be ignored or not.
 * Also, we use parseFile to search which classes are defined within ourselves,
 * otherwise we couldn't use a version of phuild.php generated by phuild with
 * sources included. 
 */
$declared = array_merge(get_declared_classes(), get_declared_interfaces());
function parseFile($file):array {
	$string = file_get_contents($file);
	$tokens = token_get_all($string);
	$names = array();
	$interesting = array(T_CLASS, T_INTERFACE);
	foreach($tokens as $key => $value) {
		if(!is_array($value)) {
			continue;
		}
		if(!in_array($value[0], $interesting)) {
			continue;
		}
		if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
			continue;
		}
		if($tokens[$key+1][0]!=T_WHITESPACE) {
			continue;
		}
		$names[] = $tokens[$key+2][1];
	}
return $names;
}
$decSelf = parseFile(__FILE__);
$ignore = array();
foreach($declared as $value) {
	if(in_array($value, $decSelf)) {
		continue;
	}
	$ignore[] = $value;
}
$ignore[] = "self";
$ignore[] = "parent";

#Include
#Imported from ./include/lib/Argv/ArgvModel.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Interface for model as expected by Argv.
 */
interface ArgvModel {
	/**
	 * The amount of defined parameters; valued parameters only.
	 */
	function getParamCount():int;
	/**
	 * Get a specific arg model.
	 * @param int $arg
	 */
	function getArgModel(int $arg): ArgModel;
	/**
	 * return an array of pure boolean parameters without a value, which will
	 * evaluate to true if set.
	 */
	function getBoolean(): array;
}
#Imported from ./include/lib/Argv/ArgModel.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Interface for return value of Argv::getArgModel.
 *
 * ArgvModel allows to define parameters along with conversion and validation.
 * Examples may be to validate that a parameter like --date= contains a valid
 * date.
 */
interface ArgModel {
	/**
	 * „Long“ name of a parameter, expecting two hyphens (ie. --date).
	 */
	function getLongName():string;
	/**
	 * returns a default value if it has one. If, for instance, --date is used,
	 * it could be set to „now“.
	 */
	function getDefault(): string;
	/**
	 * Should return whether an instance of ArgModel has a default value or not.
	 */
	function hasDefault():bool;
	/**
	 * Should return whether an instance of ArgModel has an instance of Validate
	 * defined.
	 */
	function hasValidate():bool;
	/**
	 * Should return an instance of Validate if there is one; Argv will then
	 * call it on the value given by a parameter. getValidate won't be called if
	 * hasValidate returns false.
	 */
	function getValidate():Validate;
	/**
	 * Should return whether an instance of ArgModel has an instance of Convert
	 * defined.
	 */
	function hasConvert():bool;
	/**
	 * Should return an instance of Convert if there is one; Argv will then use
	 * it to convert any input.
	 */
	function getConvert():Convert;
	function isMandatory():bool;
}
#Imported from ./include/lib/Argv/ArgString.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */
class ArgString implements ArgModel {
	private $name;
	private $default;
	private $mandatory = false;
	private $validate;
	private $convert;
	public function __construct(string $name, string $default = "") {
		$this->name = $name;
		$this->default = $default;
	}

	public function setMandatory(bool $mandatory) {
		$this->mandatory = $mandatory;
	}
	
	public function setValidate(Validate $validate) {
		$this->validate = $validate;
	}
	
	public function setConvert(Convert $convert) {
		$this->convert = $convert;
	}
	
	public function getConvert(): Convert {
		return $this->convert;
	}

	public function getDefault(): string {
		return $this->default;
	}

	public function getLongName(): string {
		return $this->name;
	}

	public function getShortName(): string {
		
	}

	public function getValidate(): Validate {
		return $this->validate;
	}

	public function hasConvert(): bool {
		return $this->convert!=NULL;
	}

	public function hasDefault(): bool {
		return $this->default!=="";
	}

	public function hasValidate(): bool {
		return $this->validate!=NULL;
	}

	public function isMandatory(): bool {
		return $this->mandatory;
	}

}
#Imported from ./include/local/ArgvMain.php


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of ArgvMain
 *
 * @author hm
 */
class ArgvMain implements ArgvModel{
	private $arg = array();
	public function __construct() {
		$file = new ArgString("output");
		$this->arg[] = $file;
	}
	public function getArgModel(int $arg): \ArgModel {
		return $this->arg[$arg];
	}

	public function getBoolean(): array {
		return array("source", "require", "check", "force");
	}

	public function getParamCount(): int {
		return count($this->arg);
	}

}
#Imported from ./include/lib/Argv/Argv.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license LGPL
 */

/**
 * Argv extracts parameters from $argv, as defined in an ArgvModel. As of yet,
 * it only handles long parameters, such as --param, both with or without a
 * value.<br />
 * Argv does basic plausibility checks; it throws Exceptions if boolean
 * parameters are used with a value and vice versa or if unknown parameters are
 * used.
 */
class Argv {
	private $model;
	private $long;
	private $argv;
	private $argvResult = array();
	private $boolean = array();
	private $longParams = array();
	function __construct(array $argv, ArgvModel $model) {
		$this->model = $model;
		$this->argv = array_slice($argv, 1);
		for($i = 0; $i<$this->model->getParamCount();$i++) {
			$this->longParams[] = $this->model->getArgModel($i)->getLongName();
		}
		foreach($this->argv as $key => $value) {
			if(substr($value, 0, 2)=="--") {
				$this->extractAll($value);
			}
		}
		$this->extract();
	}
	
	private function extractAll($value) {
		$explode = explode("=", $value, 2);
		$name = substr($explode[0], 2);
		//checks whether a parameter is defined.
		if(!in_array($name, $this->longParams) && !in_array($name, $this->model->getBoolean())) {
			throw new InvalidArgumentException("Unknown parameter --".$name);
		}
		//checks if a boolean parameter is without a value.
		if(count($explode)==2 && in_array($name, $this->model->getBoolean())) {
			throw new InvalidArgumentException("Boolean parameter --".$name." must not have value");
		}
		//checks whether a non-boolean parameter has a value.
		if(count($explode)==1 && in_array($name, $this->longParams)) {
			throw new InvalidArgumentException("Parameter --".$name." expects value");
		}
		
		if(count($explode)==2) {
			$this->long[$name] = $explode[1];
		} else {
			$this->long[$name] = true;
		}
	}
	
	private function extractValue(ArgModel $arg) {
		if(!isset($this->long[$arg->getLongName()]) && $arg->isMandatory()) {
			throw new Exception("--".$arg->getLongName()." is mandatory");
		}
		if(!isset($this->long[$arg->getLongName()]) && $arg->hasDefault()) {
			$this->argvResult[$arg->getLongName()] = $arg->getDefault();
			return;
		}
		if(!isset($this->long[$arg->getLongName()])) {
			return;
		}
		if($arg->hasValidate()) {
			$arg->getValidate()->validate($this->long[$arg->getLongName()]);
		}
		
		if($arg->hasConvert()) {
			$this->argvResult[$arg->getLongName()] = $arg->getConvert()->convert($this->long[$arg->getLongName()]);
			return;
		}
		$this->argvResult[$arg->getLongName()] = $this->long[$arg->getLongName()];
	}
	
	private function extract() {
		for($i=0;$i<$this->model->getParamCount();$i++) {
			$arg = $this->model->getArgModel($i);
			$this->extractValue($arg);
		}
		foreach($this->model->getBoolean() as $value) {
			if(!isset($this->long[$value])) {
				$this->boolean[$value] = false;
				continue;
			}
			$this->boolean[$value] = true;
		}
	}
	
	/**
	 * Checks whether a certain parameter is available or not. A parameter is
	 * available if it was used by the calling user or if it's ArgModel has a
	 * default value.
	 * @param type $key
	 * @return bool
	 */
	function hasValue($key):bool {
		return isset($this->argvResult[$key]);
	}
	/**
	 * Gets the value of a specific parameter. Note that parameters which are
	 * not available will throw an exception, so hasValue should be called
	 * beforehand if a value is not mandatory and has no default value.
	 * 
	 * @param type $key
	 * @return string
	 * @throws Exception
	 */
	function getValue($key): string {
		if(!$this->hasValue($key)) {
			throw new Exception("argument value ".$key." doesn't exist");
		}
	return $this->argvResult[$key];
	}
	
	/**
	 * getBoolean will evaluate to true if a parameter was set (like --force),
	 * and to false, if it was not set. It will throw an Exception if it was
	 * not defined in an instance of ArgvModel.
	 * @param type $key
	 * @return bool
	 * @throws Exception
	 */
	function getBoolean($key):bool {
		if(!isset($this->boolean[$key])) {
			throw new Exception("boolean argument ".$key." is not defined");
		}
	return $this->boolean[$key];
	}
}
#Imported from ./include/local/ComponentsAvailable.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class ComponentsAvailable {
	private $folder;
	private $files;
	private $classes;
	private $sort;
	function __construct(string $folder) {
		$this->folder = realpath($folder);
		$this->recurse($this->folder);
	}
	
	private function recurse($folder) {
		foreach(glob($folder."/*") as $value) {
			$info = pathinfo($value);
			if(is_dir($value)) {
				$this->recurse($value);
				continue;
			}
			if(!isset($info["extension"])) {
				continue;
			}
			if($info["extension"]!="php") {
				continue;
			}
			$this->parse($value);
		}
	}

	private function parse($file) {
		$string = file_get_contents($file);
		$tokens = token_get_all($string);

		$interesting = array(T_CLASS, T_INTERFACE);
		foreach($tokens as $key => $value) {
			if(!is_array($value)) {
				continue;
			}
			if(!in_array($value[0], $interesting)) {
				continue;
			}
			if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
				continue;
			}
			if($tokens[$key+1][0]!=T_WHITESPACE) {
				continue;
			}
			$this->classes[$tokens[$key+2][1]] = $file;
		}
	}
	
	public function getComponent(string $component) {
		if(!$this->hasComponent($component)) {
			throw new Exception("component ".$component." not known.");
		}
		return $this->classes[$component];
	}
	
	public function hasComponent(string $component):bool {
		return isset($this->classes[$component]);
	}
}
#Imported from ./include/local/ComponentsNeeded.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class ComponentsNeeded {
	private $main;
	private $classes = array();
	private $components;
	private $ignore = array();
	const REQONCE = 1;
	const SOURCE = 2;
	function __construct($file, ComponentsAvailable $ca, array $ignore) {
		$this->main = realpath($file);
		$this->components = $ca;
		$this->ignore = $ignore;
		$this->parse($file);
	}

	private function addClass(string $file, string $className) {
		if(in_array($className, $this->ignore)) {
			return;
		}
		if(!$this->components->hasComponent($className)) {
			$this->classes[] = $className;
			return;
		}

		/**
		 * Fill ignore first, to prevent that classes get added for several
		 * times.
		 */
		$this->ignore[] = $className;
		$this->parse($this->components->getComponent($className));
		/**
		 * Fill classes after parse, to ensure proper dependency, ie what's
		 * needed is added before what needs it.
		 */
		$this->classes[] = $className;
	}
	
	private function getMainFile(): string {
		$result = "";
		$bb = false;
		$file = file($this->main);
		foreach($file as $line) {
			$trimmed = trim($line);
			if($trimmed=="#Include") {
				$result .= $line;
				$bb = true;
				continue;
			}
			if($trimmed=="#/Include") {
				$result .= $line;
				$bb = false;
				continue;
			}
			if($bb == true) {
				continue;
			}
		$result .= $line;
		}
	return $result;
	}
	
	private function parse($file) {
		if($file==$this->main) {
			/**
			 * Any #Build block has to be ignored for the main file, as code
			 * therein will be replaced and must not trigger dependencies.
			 */
			$string = $this->getMainFile();
		} else {
			$string = file_get_contents($file);
		}
		$tokens = token_get_all($string);

		$interesting = array(T_IMPLEMENTS, T_EXTENDS, T_NEW);
		foreach($tokens as $key => $value) {
			if(!is_array($value)) {
				continue;
			}
			if($value[0]==T_DOUBLE_COLON) {
				$className = $tokens[$key-1][1];
				$this->addClass($file, $className);
				continue;
			}
			if(!in_array($value[0], $interesting)) {
				continue;
			}
			if(!isset($tokens[$key+1]) || !isset($tokens[$key+2])) {
				continue;
			}
			if($tokens[$key+1][0]!=T_WHITESPACE) {
				continue;
			}
			$className = $tokens[$key+2][1];
			$this->addClass($file, $className);
		}
	}
	
	function getClasses(): array {
		return $this->classes;
	}
	
	private function getRequireOnce(): string {
		$require = "";
		foreach($this->classes as $key => $value) {
			$require .= "require_once ".str_replace(dirname($this->main), "__DIR__.'", $this->components->getComponent($value))."';".PHP_EOL;
		}
	return $require;
	}
	
	private function getSource(): string {
		$replace = "";
		foreach($this->classes as $key => $value) {
			$file = trim(file_get_contents($this->components->getComponent($value)));
			$exp = explode(PHP_EOL, $file);
			$exp[0] = "#Imported from ".str_replace(dirname($this->main), ".", $this->components->getComponent($value)).PHP_EOL;
			if($exp[count($exp)-1]=="?>") {
				array_pop($exp);
			}
			$replace .= implode(PHP_EOL, $exp).PHP_EOL;
		}
	return $replace;
	}
	
	private function getReplace($type): string {
		$new = "";
		if($type==self::REQONCE) {
			$new .= $this->getRequireOnce();
		}
		if($type==self::SOURCE) {
			$new .= $this->getSource();
		}
	return $new;
	}
	
	function replace(int $type):string {
		$replace = false;
		$new = "";
		$handle = fopen($this->main, "r");
		while($line = fgets($handle)) {
			$trimmed = trim($line);
			if($trimmed=="#Include") {
				$new .= $line;
				$replace = true;
				continue;
			}
			if($trimmed=="#/Include") {
				$new .= $this->getReplace($type);
				$new .= $line;
				$replace = FALSE;
				continue;
			}
			if($replace==true) {
				continue;
			}
			$new .= $line;
		}
		fclose($handle);
	return $new;
	}
	
	private function printCheckResult(array $array, string $heading) {
		foreach($array as $key => $value) {
			if($key==0) {
				echo $heading.PHP_EOL;
			}
			echo "\t".$value.PHP_EOL;
		}
	}
	
	function check() {
		$available = array();
		$missing = array();
		foreach($this->classes as $value) {
			if($this->components->hasComponent($value)) {
				$available[] = $value;
			} else {
				$missing[] = $value;
			}
		}
		$this->printCheckResult($available, "Available Components:");
		$this->printCheckResult($missing, "Missing Components:");
	}
}
#Imported from ./include/local/Main.php

/**
 * @copyright (c) 2019, Claus-Christoph Küthe
 * @author Claus-Christoph Küthe <floss@vm01.telton.de>
 * @license GPLv3
 */
class Main {
	private $file;
	private $target;
	private $sourcePath;
	private $needed;
	private $available;
	private $argv;
	function __construct(array $argv, array $ignore) {
		if(!isset($argv[1])) {
			throw new Exception("Usage: phuild.php <filename> [parameters]");
			die();
		}
		if(!file_exists($argv[1])) {
			throw new Exception("file does not exist.");
		}
		$model = new ArgvMain();
		$this->argv = new Argv($argv, $model);
		$boolean = array("source", "require", "check");
		$boolCount = 0;
		foreach($boolean as $value) {
			if($this->argv->getBoolean($value)) {
				$boolCount++;
			}
			if($boolCount>1) {
				throw new Exception("--source, --check and --require are mutually exclusive.");
			}
		}
		if($boolCount==0) {
			throw new Exception("Needs --source, --check or --require");
		}
		$this->file = $argv[1];
		$this->sourcePath = dirname($this->file);
		$this->available = new ComponentsAvailable($this->sourcePath);
		$this->needed = new ComponentsNeeded($this->file, $this->available, $ignore);
	}
	
	private function saveFile() {
		if($this->argv->getBoolean("check")) {
			return;
		}
		if($this->argv->getBoolean("source")) {
			$replaced = $this->needed->replace(ComponentsNeeded::SOURCE);
		}
		if($this->argv->getBoolean("require")) {
			$replaced = $this->needed->replace(ComponentsNeeded::REQONCE);
		}
		if(!$this->argv->hasValue("output")) {
			echo $replaced.PHP_EOL;
			return;
		}
		if(file_exists($this->argv->getValue("output")) && !$this->argv->getBoolean("force")) {
			throw new Exception("file ".$this->argv->getValue("output")." already exists, use --force to replace.");
		}
		file_put_contents($this->argv->getValue("output"), $replaced);
	}
	
	function run() {
		$this->saveFile();
		if($this->argv->getBoolean("check")) {
			$this->needed->check();
		}
	}
}
#/Include

try {
	$main = new Main($argv, $ignore);
	$main->run();
} catch (Exception $ex) {
	echo $ex->getMessage().PHP_EOL;
}